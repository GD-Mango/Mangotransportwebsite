-- Migration: Create atomic booking creation function
-- This ensures booking, receivers, and packages are created in a single transaction
-- Prevents orphaned records if any step fails

-- First, ensure we have version tracking for conflict detection
ALTER TABLE bookings ADD COLUMN IF NOT EXISTS updated_at TIMESTAMPTZ DEFAULT NOW();
ALTER TABLE bookings ADD COLUMN IF NOT EXISTS version INTEGER DEFAULT 1;

-- Create or replace the trigger function for version tracking
CREATE OR REPLACE FUNCTION update_booking_version()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    NEW.version = COALESCE(OLD.version, 0) + 1;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Drop existing trigger if exists and recreate
DROP TRIGGER IF EXISTS update_bookings_version_trigger ON bookings;
CREATE TRIGGER update_bookings_version_trigger
    BEFORE UPDATE ON bookings
    FOR EACH ROW
    EXECUTE FUNCTION update_booking_version();

-- Main atomic booking creation function
CREATE OR REPLACE FUNCTION create_booking_atomic(
  p_booking JSONB,
  p_receivers JSONB
)
RETURNS JSONB
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_booking_id UUID;
  v_receipt_number TEXT;
  v_receiver JSONB;
  v_receiver_id UUID;
  v_package JSONB;
  v_result JSONB;
  v_receiver_order INTEGER := 0;
BEGIN
  -- Insert booking record (receipt_number auto-generated by existing trigger)
  INSERT INTO bookings (
    origin_depot_id,
    destination_depot_id,
    payment_method,
    delivery_type,
    delivery_charges,
    sender_name,
    sender_phone,
    subtotal,
    total_amount,
    status,
    custom_instructions,
    version
  ) VALUES (
    (p_booking->>'origin_depot_id')::UUID,
    (p_booking->>'destination_depot_id')::UUID,
    p_booking->>'payment_method',
    p_booking->>'delivery_type',
    COALESCE((p_booking->>'delivery_charges')::NUMERIC, 0),
    p_booking->>'sender_name',
    p_booking->>'sender_phone',
    COALESCE((p_booking->>'subtotal')::NUMERIC, 0),
    COALESCE((p_booking->>'total_amount')::NUMERIC, 0),
    COALESCE(p_booking->>'status', 'booked'),
    p_booking->>'custom_instructions',
    1
  )
  RETURNING id, receipt_number INTO v_booking_id, v_receipt_number;

  -- Insert receivers and their packages
  FOR v_receiver IN SELECT * FROM jsonb_array_elements(p_receivers)
  LOOP
    v_receiver_order := v_receiver_order + 1;
    
    INSERT INTO booking_receivers (
      booking_id,
      receiver_name,
      receiver_phone,
      delivery_address,
      receiver_order
    ) VALUES (
      v_booking_id,
      v_receiver->>'name',
      v_receiver->>'phone',
      v_receiver->>'address',
      COALESCE((v_receiver->>'order')::INTEGER, v_receiver_order)
    )
    RETURNING id INTO v_receiver_id;

    -- Insert packages for this receiver
    IF v_receiver->'packages' IS NOT NULL THEN
      FOR v_package IN SELECT * FROM jsonb_array_elements(v_receiver->'packages')
      LOOP
        INSERT INTO receiver_packages (
          receiver_id,
          package_id,
          package_size,
          quantity,
          price_per_unit,
          description
        ) VALUES (
          v_receiver_id,
          -- Only use package_id if it's a valid UUID (length > 10)
          CASE 
            WHEN v_package->>'packageId' IS NOT NULL 
                 AND v_package->>'packageId' != 'custom'
                 AND length(v_package->>'packageId') > 10 
            THEN (v_package->>'packageId')::UUID 
            ELSE NULL 
          END,
          COALESCE(v_package->>'size', 'Custom'),
          COALESCE((v_package->>'quantity')::INTEGER, 1),
          COALESCE((v_package->>'price')::NUMERIC, 0),
          v_package->>'description'
        );
      END LOOP;
    END IF;
  END LOOP;

  -- Build success result
  v_result := jsonb_build_object(
    'id', v_booking_id,
    'receipt_number', v_receipt_number,
    'success', true
  );
  
  RETURN v_result;

EXCEPTION WHEN OTHERS THEN
  -- Transaction is automatically rolled back
  -- Re-raise with more context
  RAISE EXCEPTION 'Booking creation failed: % (SQLSTATE: %)', SQLERRM, SQLSTATE;
END;
$$;

-- Grant execute permission to authenticated users
GRANT EXECUTE ON FUNCTION create_booking_atomic(JSONB, JSONB) TO authenticated;
GRANT EXECUTE ON FUNCTION create_booking_atomic(JSONB, JSONB) TO anon;

-- Also add version tracking to trips table for consistency
ALTER TABLE trips ADD COLUMN IF NOT EXISTS updated_at TIMESTAMPTZ DEFAULT NOW();
ALTER TABLE trips ADD COLUMN IF NOT EXISTS version INTEGER DEFAULT 1;

-- Create trigger for trips version tracking
CREATE OR REPLACE FUNCTION update_trip_version()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    NEW.version = COALESCE(OLD.version, 0) + 1;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS update_trips_version_trigger ON trips;
CREATE TRIGGER update_trips_version_trigger
    BEFORE UPDATE ON trips
    FOR EACH ROW
    EXECUTE FUNCTION update_trip_version();

COMMENT ON FUNCTION create_booking_atomic IS 'Atomically creates a booking with all receivers and packages in a single transaction';
